<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GENCG - Working Journal</title>
    <link rel="stylesheet" href="../style.css" />
    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?skin=sunburst"></script>
  </head>
  <body>
    <section id="navBar" class="hidden">
      <section id="links">
        <a href="../index.html">GENCG Introduction</a>
        <hr />

        <a href="day_1.html">Day 1 - Physical Games</a>
        <hr />

        <a href="day_2.html">Day 2 - Grid Patterns</a>
        <hr />

        <a href="day_3.html">Day 3 - Time Visualization</a>
        <hr />

        <a href="day_4.html">Day 4 - Drawing Machine</a>
        <hr />

        <a href="day_5.html">Day 5 - Face Generator</a>
        <hr />

        <a href="day_6.html">Day 6 - Pixel Manipulations</a>
        v
        <a href="day_7.html">Day 7 & 8 - Extended Projects</a>
      </section>
      <div id="flap"><div id="flapArrow">></div></div>
    </section>
    <section id="content">
      <h1 id="title">GENCG Working Journal - Day 2 - Grid Patterns</h1>
      <hr />
      <article>
        Today we started working on some iterative patterns in a grid. To start
        things off I made some sketches of what I'd like to create in software
        afterwards.
      </article>
      <div class="grid_3x1">
        <img src="images/grid_1.jpg" alt="" />
        <img src="images/grid_2.jpg" alt="" />
        <img src="images/grid_3.jpg" alt="" />
      </div>
      <article>
        The lines in the first two examples should rotate itself in order to
        follow the mouse position. First I tried to solve this by using the
        built-in transformation functions from P5JS.
      </article>
      <pre class="prettyprint">
        // draw lines in a grid
        for (let y = tileWidth / 2; y < rows * tileWidth; y += tileWidth) {
          for (let x = tileWidth / 2; x < cols * tileWidth; x += tileWidth) {
            push();
            // calculate the angle so the line points to the mouse position
            let angle = Math.atan2(mouseY - y, mouseX - x);
            rotate(angle);
            line(x - tileWidth / 2, y, x + tileWidth / 2, y);
            pop();
          }
        }        
        </pre
      >
      <iframe
        src="../sketches/day_2_grid_patterns/failedFollowMouse/index.html"
        frameborder="0"
        ,
        style="width: 100%; height: 40vw"
      ></iframe>
      <a
        href="../sketches/day_2_grid_patterns/failedFollowMouse/index.html"
        class="sketchLink"
        target="_blank"
        >Show me!</a
      >
      <article>
        I must have gotten some calculation wrong, probably i'd need to do a
        translate before I apply the rotate function. Nevertheless it looks
        kinda cool. Also this failed example has something to it.
      </article>

      <iframe
        src="../sketches/day_2_grid_patterns/failedFollowMouse_2/index.html"
        frameborder="0"
        ,
        style="width: 100%; height: 40vw"
      ></iframe>
      <a
        href="../sketches/day_2_grid_patterns/failedFollowMouse_2/index.html"
        class="sketchLink"
        target="_blank"
        >Show me!</a
      >
      <article>
        Finally I decided to do the maths by myself, so I wouldn't get confused
        by the whole push and pop mechanic of P5JS.Because it took me so long to
        get this example right, I didn't manage to implement the third sketch I
        had initially planned.
      </article>
      <iframe
        src="../sketches/day_2_grid_patterns/followMouse_1/index.html"
        frameborder="0"
        ,
        style="width: 100%; height: 40vw"
      ></iframe>
      <a
        href="../sketches/day_2_grid_patterns/followMouse_1/index.html"
        class="sketchLink"
        target="_blank"
        >Show me!</a
      >

      <pre class="prettyprint">
        // draw lines in a grid
        for (let iY = 0; iY < rows; iY++) {
            for (let iX = 0; iX < cols; iX++) {
              let x = iX * tileWidth;
              let y = iY * tileWidth;
              let angle = atan2(mouseY - y, mouseX - x);
              //here I manually calculate the start and end points of the line instead of using rotate()
              line(x - cos(angle) * tileWidth / 2, y - sin(angle) * tileWidth / 2, x + cos(angle) * tileWidth / 2, y + sin(angle) * tileWidth / 2);
            }    
        }      
    </pre
      >
      <article>
        Instead of starting a whole new sketch, I wanted to develop this one a
        bit further. Instead of redrawing the background each frame, I left the
        existing lines stay, but reduced the opacity, so overlapping lines would
        be more visible. Also I added some <strong>sine</strong> and
        <strong>cosine</strong> functions to the length of each line over time.
        And finally I mapped the <strong>color</strong> and
        <strong>thickness</strong> of each line to the current
        <strong>mouseposition</strong> on the canvas.
      </article>
      <iframe
        src="../sketches/day_2_grid_patterns/followMouse_2/index.html"
        frameborder="0"
        ,
        style="width: 100%; height: 40vw"
      ></iframe>
      <a
        href="../sketches/day_2_grid_patterns/followMouse_2/index.html"
        class="sketchLink"
        target="_blank"
        >Show me!</a
      >
    </section>

    <script src="../script.js"></script>
  </body>
</html>
